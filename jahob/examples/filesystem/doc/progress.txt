Goal: Want to verify that operations on disk blocks do not violate file system invariantsIssue: Disk is simply an array of bytes. Need to abstract the disk contents into an analyzable form.Disk contains 	1) Boot block	2) Super block	3) Inodes	4) Data  block			directories				file dataProblem:	what OO representation should be used	can't put the OO representation into memory and analyze it.Goal2: Verify that the operations move the file system from a valid to state to another valid state.		a state is valid if it satisfies the invariantsApproach: 	First, just implement the file system for the purposes of functionality constrained by efficiency:		i.e. memory used should be O(size of disk) not O(number of requests)		Entail reading and writing bytes into disk blocks				Problem: semantics of disk blocks hidden and hard to analyze			why?semantics hidden because all we have is a sequence of bytes without structure but, the structure is there if we interpret the bytes with regard to some semantics in other words, our specifications need to abstract the file system operations to operate on the file system abstract model, while the actual code only reads/writes bytes What is the abstract model? (disk data structure)	the disk is a tuple:		1) set of inodes	I <= D U F where D is the set of directory inodes and F is set of files		2) directory structure graph D = (V, E) where V <= D U F & E = {(x,y) I x:D & y : D U F & y.inodeid exists in x's directory block entries}		3) superblock bsuper		4) relation from inodes to disk block listSpecifications need to abstract character writing to the abstract model. Then can use the model to verify the invariants But, the whole point of this system to verify a data structure:	yes, and the disk one enormous data structure _encoded_ as an array of bytes	we also have implementation data structures used to maintainTwo classes of data structures:	1) the disk data strucure (see abstract model)		ex. disk inode, super block, directory blocks, file data blocks	2) data structures used by file system to maintain the disk data structures		ex. file descriptor table, open file table, incore inode buffersNotes on java:1) promotes liberal object instantiation to increase programmer productivity	but, can't use this programming paradigm for building systems that obey stringent memory requirementsGoal: A combination of both worlds: the increase of programmer productivity experienced by liberal object instantition without the liberal object instantiation.	Use dynamic field introduction - hard. not clear whether more efficient	- actual the real thing that field introduction offers is more powerful access control: can reverse "knowledge" dependencyApproach:	1) Implement the file system without care about how its will be verified		do not liberally instantiate objects to improve design	2) Go back and decompose the code to make model more explicit	3) Specify and enumerate invariants	4) Write description of file system explaining the data structures (diagrams?)	5) reformulate getBlock to extract body from retry loop	6) rewrite invariants in terms typestate for buffers	7) implement generics and packages	8) verify buffer cache invariantsStep 1: Implement the file systemsx 1. disk x 2. buffer cache- 3. inode cache	serialization of in core inodes			set size	inode data block table	bmap	file system constants: disk inode size4. directories: namei5. superblock data structures6. ialloc, ifree7. alloc, free8. open, read, write, lseek, close, creat, chdirplugin to analyze linked data structures expressed as addressable arrays?